<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Speech Disturbance Test (SARA‚Äë4 compatible) ‚Äî Browser MVP</title>
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --accent:#10b981; --muted:#94a3b8; --danger:#ef4444; --ok:#22c55e; color-scheme:dark
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:#e6eef6}
    .app{max-width:980px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:16px}
    header{display:flex;justify-content:space-between;align-items:center;gap:8px}
    h1{font-size:22px;margin:0}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .card{background:var(--panel);border:1px solid #1b2438;border-radius:12px;padding:14px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    label{font-size:12px;color:var(--muted)}
    select,input[type="text"],input[type="number"]{background:#0e1627;border:1px solid #1f2a44;color:#e6eef6;border-radius:8px;padding:8px}
    button{background:var(--accent);border:0;color:#052012;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.secondary{background:#111827;color:#d1d5db;border:1px solid #1f2a44}
    button.danger{background:var(--danger);color:white}
    button:disabled{opacity:.5;cursor:not-allowed}
    .pill{padding:4px 8px;border-radius:999px;background:#0e1627;border:1px solid #1f2a44;color:#cbd5e1;font-size:12px}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:900px){.grid{grid-template-columns:2fr 1fr}}
    audio{width:100%}
    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{border-bottom:1px solid #1f2a44;padding:6px 8px;text-align:left}
    .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
    .small{font-size:12px;color:var(--muted)}
    .ok{color:var(--ok)}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Speech Disturbance Test ¬∑ Reading (5 Sentences)</h1>
      <div class="row">
        <span class="pill" id="status">Idle</span>
        <button id="btn-permission" class="secondary">üéôÔ∏è Mic Permission</button>
      </div>
    </header>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:flex-end">
        <div>
          <div class="row">
            <label>Participant ID</label>
            <input id="pid" type="text" placeholder="e.g., P001" style="width:120px" />
            <label>Session</label>
            <input id="sid" type="text" placeholder="S1" style="width:80px" />
            <label>Mic distance (cm)</label>
            <input id="micdist" type="number" value="12" style="width:80px"/>
          </div>
          <div class="small" style="margin-top:6px">Environment: quiet room (‚â§45 dB) recommended ¬∑ noiseSuppression/echoCancellation ON</div>
        </div>
        <div class="controls">
          <button id="btn-start">‚ñ∂ Start Test</button>
          <button id="btn-stop" class="danger" disabled>‚ñ† Stop</button>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h3 style="margin-top:0">Instructions</h3>
        <div id="task-instructions" class="mono small"></div>
        <div class="controls" style="margin-top:10px">
          <button id="btn-record" disabled>‚óè Start Recording</button>
          <button id="btn-done" class="secondary" disabled>Next ‚Üí</button>
        </div>
        <div style="margin-top:10px">
          <audio id="playback" controls></audio>
        </div>
      </div>

      <div class="card">
        <h3 style="margin-top:0">Live Monitor</h3>
        <div class="small">Input: <span id="caps">‚Äî</span> | SR: <span id="sr">‚Äî</span></div>
        <div class="small">Level (RMS): <span id="rms">0.000</span></div>
        <div class="small">Estimated F0 (Hz): <span id="f0">‚Äî</span></div>
        <canvas id="meter" width="320" height="40" style="background:#0e1627;border:1px solid #1f2a44;border-radius:8px;margin-top:6px"></canvas>
      </div>
    </div>

    <div class="card">
      <h3 style="margin-top:0">Results</h3>
      <div class="controls">
        <button id="btn-export-csv" class="secondary" disabled>Export CSV</button>
        <button id="btn-export-json" class="secondary" disabled>Export JSON</button>
        <button id="btn-clear" class="secondary" disabled>Clear</button>
      </div>
      <div class="small" style="margin-top:8px">Each segment is saved with its features. Audio is captured by the browser's MediaRecorder (webm/opus or similar).</div>
      <table style="margin-top:10px">
        <thead>
          <tr><th>#</th><th>Test</th><th>Duration(s)</th><th>Mean RMS</th><th>Mean F0(Hz)</th><th>DL</th></tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>

    <footer class="small">Protocol: Read the 5 sentences below, one per test. Speak clearly and at a natural pace.</footer>
  </div>

<script>
(function(){
  // ------------------------------
  // Sentences to read (can be edited)
  // ------------------------------
  const SENTENCES = [
    'The quick brown fox jumps over the lazy dog.',
    'We were away a year ago, and we saw a wide view of the valley.',
    'Please pack my box with five dozen liquor jugs.',
    'She sells sea shells by the sea shore.',
    'Many men, many minds; every voice tells a different story.'
  ];

  // Build 5 "tests" out of the sentences
  const TASKS = SENTENCES.map((text, i) => ({
    key: `test${i+1}`,
    title: `Test ${i+1}`,
    seconds: 8, // recording window per sentence
    repeat: 1,
    prompt: `Read aloud: "${text}"`
  }));

  // ------------------------------
  // State
  // ------------------------------
  let stream, audioCtx, analyser, source;
  let mediaRecorder, chunks = [];
  let state = { iTask: -1, iRep: 0, running: false, sampleRate: null };
  const results = []; // {task, rep, blob, duration, features}

  // UI refs
  const $ = sel => document.querySelector(sel);
  const els = {
    status: $('#status'), caps: $('#caps'), sr: $('#sr'), rms: $('#rms'), f0: $('#f0'), meter: $('#meter'),
    instr: $('#task-instructions'), playback: $('#playback'), rows: $('#rows'),
    btnPerm: $('#btn-permission'), btnStart: $('#btn-start'), btnStop: $('#btn-stop'), btnRecord: $('#btn-record'), btnDone: $('#btn-done'),
    btnCSV: $('#btn-export-csv'), btnJSON: $('#btn-export-json'), btnClear: $('#btn-clear'),
    pid: $('#pid'), sid: $('#sid'), micdist: $('#micdist')
  };

  // ------------------------------
  // Mic & monitor
  // ------------------------------
  async function ensureMic(){
    if(stream) return stream;
    stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        channelCount: 1,
        noiseSuppression: true,
        echoCancellation: true,
        autoGainControl: false
      }
    });
    setupMonitor(stream);
    els.status.textContent = 'Mic ready';
    return stream;
  }

  function setupMonitor(str){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.sampleRate = audioCtx.sampleRate;
    els.sr.textContent = `${Math.round(state.sampleRate)} Hz`;
    source = audioCtx.createMediaStreamSource(str);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    source.connect(analyser);

    const timeData = new Float32Array(analyser.fftSize);
    const ctx = els.meter.getContext('2d');

    function loop(){
      if(!analyser) return;
      analyser.getFloatTimeDomainData(timeData);
      const rms = Math.sqrt(timeData.reduce((s,v)=>s+v*v,0)/timeData.length) || 0;
      els.rms.textContent = rms.toFixed(3);
      drawMeter(ctx, rms);

      const f0 = estimateF0(timeData, state.sampleRate);
      els.f0.textContent = f0 ? f0.toFixed(1) : '‚Äî';
      requestAnimationFrame(loop);
    }
    loop();
  }

  function drawMeter(ctx, rms){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#1f2a44';
    ctx.fillRect(0,0,w,h);
    const v = Math.min(1, rms * 10);
    ctx.fillStyle = '#10b981';
    ctx.fillRect(0,0,w*v,h);
  }

  // Simple autocorrelation-based F0 (works for clean vowels; heuristic)
  function estimateF0(buf, sr){
    let mean = 0; for(let i=0;i<buf.length;i++) mean += buf[i]; mean/=buf.length;
    const x = new Float32Array(buf.length); for(let i=0;i<buf.length;i++) x[i]=buf[i]-mean;
    const n = x.length; const corr = new Float32Array(n);
    for(let lag=0;lag<n;lag++){
      let s=0; for(let i=0;i<n-lag;i++){ s += x[i]*x[i+lag]; }
      corr[lag]=s;
    }
    const minLag = Math.floor(sr/400), maxLag = Math.floor(sr/60);
    let bestLag=0, bestVal=-1;
    for(let lag=minLag; lag<=Math.min(maxLag, n-1); lag++){
      if(corr[lag] > bestVal){ bestVal = corr[lag]; bestLag = lag; }
    }
    if(bestLag>0) return sr / bestLag; else return null;
  }

  // ------------------------------
  // Recording pipeline
  // ------------------------------
  function startRecording(){
    chunks = [];
    mediaRecorder = new MediaRecorder(stream, { mimeType: pickMime() });
    mediaRecorder.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = () => { handleRecordingStop(); };
    mediaRecorder.start();
    els.status.textContent = 'Recording‚Ä¶';
  }
  function stopRecording(){ mediaRecorder && mediaRecorder.state==='recording' && mediaRecorder.stop(); }
  function pickMime(){
    const prefs = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus'];
    for(const m of prefs){ if(MediaRecorder.isTypeSupported(m)) return m; }
    return '';
  }

  async function handleRecordingStop(){
    const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
    const url = URL.createObjectURL(blob);
    els.playback.src = url;

    const arrBuf = await blob.arrayBuffer();
    const audioCtxTmp = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await audioCtxTmp.decodeAudioData(arrBuf);
    const ch0 = decoded.getChannelData(0);
    const dur = decoded.duration;

    const rms = Math.sqrt(ch0.reduce((s,v)=>s+v*v,0)/ch0.length);
    const f0 = estimateF0(ch0.subarray(0, Math.min(ch0.length, 44100*2)), decoded.sampleRate);

    const meta = currentMeta();
    results.push({
      task: TASKS[state.iTask].key,
      taskTitle: TASKS[state.iTask].title,
      rep: state.iRep+1,
      text: SENTENCES[state.iTask],
      duration: dur,
      blob, url,
      features: { meanRMS: rms, meanF0: f0||null, sampleRate: decoded.sampleRate, ...meta }
    });
    appendRow(results.length-1);
    updateExportsEnabled();
    els.status.textContent = 'Segment saved';
  }

  function appendRow(idx){
    const r = results[idx];
    const tr = document.createElement('tr');
    const dl = document.createElement('a');
    dl.textContent = 'AUDIO'; dl.href = r.url; dl.download = `${r.features.participant}_${r.task}.webm`;
    tr.innerHTML = `<td>${idx+1}</td><td>${r.taskTitle}</td><td>${r.duration.toFixed(2)}</td><td>${r.features.meanRMS.toFixed(3)}</td><td>${r.features.meanF0?r.features.meanF0.toFixed(1):'‚Äî'}</td>`;
    const td = document.createElement('td'); td.appendChild(dl); tr.appendChild(td);
    els.rows.appendChild(tr);
  }

  function updateExportsEnabled(){
    const has = results.length>0;
    els.btnCSV.disabled = !has; els.btnJSON.disabled = !has; els.btnClear.disabled = !has;
  }

  function currentMeta(){
    return {
      participant: els.pid.value || 'NA',
      session: els.sid.value || 'S1',
      micDistanceCM: Number(els.micdist.value||0),
      recordedAt: new Date().toISOString(),
      deviceCaps: els.caps.textContent,
    };
  }

  // ------------------------------
  // Test flow
  // ------------------------------
  function setInstruction(text){ els.instr.textContent = text; }

  function beginTest(){
    state.running = true; state.iTask = 0; state.iRep = 0;
    els.status.textContent = 'Ready';
    stepUI();
  }

  function stepUI(){
    if(!state.running){ setInstruction('Test was stopped.'); return; }
    const T = TASKS[state.iTask];
    setInstruction(`‚ñ∂ ${T.title} ¬∑ ${T.prompt}`);
    els.btnRecord.disabled = false; els.btnDone.disabled = true;
  }

  function afterSegment(){
    const T = TASKS[state.iTask];
    state.iRep++;
    if(state.iRep < T.repeat){
      setInstruction(`Rest, then repeat. When ready, press ‚ÄúStart Recording‚Äù.`);
      els.btnRecord.disabled = false; els.btnDone.disabled = true;
    } else {
      state.iTask++;
      state.iRep = 0;
      if(state.iTask >= TASKS.length){
        finishTest();
      } else {
        stepUI();
      }
    }
  }

  function finishTest(){
    state.running = false;
    setInstruction('All tests are complete. Please export CSV/JSON.');
    els.status.textContent = 'Done';
    els.btnRecord.disabled = true; els.btnDone.disabled = true;
  }

  // ------------------------------
  // Exports
  // ------------------------------
  function saveText(name, text){
    const blob = new Blob([text], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=name; a.click(); URL.revokeObjectURL(url);
  }

  function exportCSV(){
    const header = ['participant','session','test','duration_s','mean_rms','mean_f0_hz','sample_rate','mic_cm','recorded_at','device_caps','text'];
    const lines = [header.join(',')];
    for(const r of results){
      const f = r.features;
      lines.push([
        f.participant,
        f.session,
        r.taskTitle,
        r.duration.toFixed(3),
        f.meanRMS?.toFixed(6) ?? '',
        f.meanF0?.toFixed(2) ?? '',
        f.sampleRate ?? '',
        f.micDistanceCM ?? '',
        f.recordedAt ?? '',
        JSON.stringify(f.deviceCaps||''),
        '"'+(r.text.replaceAll('"','\"'))+'"'
      ].join(','));
    }
    saveText(`${(results[0]?.features.participant||'session')}_speech_reading.csv`, lines.join('\n'));
  }

  function exportJSON(){
    const out = results.map(({taskTitle,duration,features,text})=>({test:taskTitle,duration,features,text}));
    saveText(`${(results[0]?.features.participant||'session')}_speech_reading.json`, JSON.stringify(out,null,2));
  }

  function clearAll(){
    results.splice(0,results.length);
    els.rows.innerHTML='';
    updateExportsEnabled();
    els.playback.removeAttribute('src');
  }

  // ------------------------------
  // Capability probe
  // ------------------------------
  async function probeCaps(){
    const devices = await navigator.mediaDevices.enumerateDevices();
    const micNames = devices.filter(d=>d.kind==='audioinput').map(d=>d.label||'Mic');
    els.caps.textContent = `${micNames[0]||'Mic'} ¬∑ noiseSuppression:on ¬∑ echoCancellation:on`;
  }

  // ------------------------------
  // Bindings
  // ------------------------------
  els.btnPerm.onclick = async()=>{ await ensureMic(); await probeCaps(); };
  els.btnStart.onclick = async()=>{ await ensureMic(); await probeCaps(); beginTest(); };
  els.btnStop.onclick = ()=>{ state.running=false; finishTest(); };

  let countdownTimer=null; let countdownLeft=0;
  els.btnRecord.onclick = ()=>{
    if(!state.running) return;
    const T = TASKS[state.iTask];
    els.btnRecord.disabled = true; els.btnDone.disabled = true;
    startRecording();
    startCountdown(T.seconds, ()=>{
      stopRecording();
      els.btnDone.disabled = false;
    });
  };
  els.btnDone.onclick = ()=>{ els.btnDone.disabled = true; afterSegment(); };

  function startCountdown(seconds, onElapsed){
    countdownLeft = seconds;
    const label = (s)=>`Recording‚Ä¶ ${s}s left`;
    els.status.textContent = label(countdownLeft);
    if(countdownTimer) clearInterval(countdownTimer);
    countdownTimer = setInterval(()=>{
      countdownLeft--;
      els.status.textContent = label(countdownLeft);
      if(countdownLeft<=0){ clearInterval(countdownTimer); onElapsed && onElapsed(); }
    },1000);
  }
})();
</script>
</body>
</html>
